<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åˆæˆå´”æ¢“ç’‡</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS reset å’ŒåŸºç¡€æ ·å¼ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* ç¦æ­¢ç§»åŠ¨ç«¯é•¿æŒ‰é€‰ä¸­æ–‡å­—å’Œå›¾ç‰‡ */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* ç¦æ­¢æ»šåŠ¨ */
            background-color: #ffe4e1;
            /* å°‘å¥³ç²‰åº•è‰² */
            font-family: 'Arial', sans-serif;
            /* æŸ”å’Œçš„èƒŒæ™¯æ¸å˜ */
            background-image: radial-gradient(circle at 50% 30%, #fff0f5 0%, #ffe4e1 80%);
        }
        /* æ¸¸æˆä¸»å®¹å™¨ */
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            /*åœ¨å¤§å±å¹•ä¸Šé™åˆ¶æœ€å¤§å®½åº¦ */
            margin: 0 auto;
            background: transparent;
        }
        /* é¡¶éƒ¨å¯¼èˆªæ  */
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d63384;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .header-icons span {
            margin-left: 10px;
            cursor: pointer;
        }
        /* æ¸¸æˆUIæ  (åˆ†æ•°å’Œä¸‹ä¸€ä¸ªæç¤º) */
        
        .game-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            color: #d63384;
            z-index: 10;
        }
        
        .score-box {
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .next-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .next-label {
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        /* ä¸‹ä¸€ä¸ªæç¤ºçš„å®¹å™¨ */
        
        #next-item-preview {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 3px solid #fff;
            overflow: hidden;
            /* ç¡®ä¿å›¾ç‰‡ä¸æº¢å‡º */
            box-shadow: 0 2px 10px rgba(214, 51, 132, 0.2);
        }
        
        #next-item-preview img {
            display: block;
            object-fit: contain;
        }
        /* Canvas ç”»å¸ƒå®¹å™¨ */
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            margin-bottom: 10px;
            overflow: hidden;
            /* å®¹å™¨è¾¹æ¡† */
            border-left: 2px solid rgba(255, 255, 255, 0.5);
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
        }
        /* å®é™…çš„æ¸¸æˆç”»å¸ƒ */
        
        #world {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* æ¸¸æˆç»“æŸé®ç½© */
        
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            color: #d63384;
            display: none;
            /* é»˜è®¤éšè— */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #game-over-overlay h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #restart-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: #d63384;
            border: none;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4);
            transition: transform 0.1s;
        }
        
        #restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="header-bar">
            <div>åˆæˆå´”æ¢“ç’‡</div>
            <div class="header-icons">
                <!-- æ–°å¢è·³è½¬æŒ‰é’® -->
                <a href="2048.html" style="text-decoration: none; margin-right: 8px;">
                    <button style="background: #ff69b4; color: white; border: 2px solid #fff; border-radius: 15px; padding: 5px 12px; cursor: pointer; font-size: 14px; font-weight: bold; box-shadow: 0 2px 5px rgba(214, 51, 132, 0.2);">
                        å»ç©2048å´”æ¢“ç’‡ ğŸ‘‰
                    </button>
                </a>
                <a href="whack.html" style="text-decoration: none; margin-right: 8px;">
                    <button style="background: #ff69b4; color: white; border: 2px solid #fff; border-radius: 15px; padding: 5px 12px; cursor: pointer; font-size: 14px; font-weight: bold; box-shadow: 0 2px 5px rgba(214, 51, 132, 0.2);">
                        å»ç©æš´æ‰“å´”æ¢“ç’‡ ğŸ‘‰
                    </button>
                </a>
            </div>
        </div>

        <div class="game-ui-bar">
            <div class="score-box"><span id="score">0</span></div>
            <div class="next-box">
                <span class="next-label">ä¸‹ä¸€ä¸ª:</span>
                <div id="next-item-preview">
                    <!-- ä¸‹ä¸€ä¸ªæç¤ºå›¾ç‰‡å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="world"></canvas>
            <div id="game-over-overlay">
                <h2>æ¸¸æˆç»“æŸ</h2>
                <button id="restart-btn">å†æ¥ä¸€æ¬¡</button>
            </div>
        </div>
    </div>


    <script>
        // ===========================
        // æ¸¸æˆé…ç½®ä¸ç´ æå®šä¹‰
        // ===========================

        const IMG_PATH = 'images/';

        // å®šä¹‰ 11 ä¸ªç­‰çº§çš„å±æ€§ï¼Œæ–°å¢ backgroundColor å’Œ borderColor
        const FRUIT_LEVELS = [{
                radius: 18,
                fileName: 'å´”æ¢“ç’‡01.gif',
                score: 2,
                backgroundColor: '#FFFACD',
                borderColor: '#FFD700'
            }, // 0 (æµ…é»„/é‡‘è‰²)
            {
                radius: 26,
                fileName: 'å´”æ¢“ç’‡02.gif',
                score: 4,
                backgroundColor: '#FFA07A',
                borderColor: '#FF4500'
            }, // 1 (æµ…æ©™/æ©˜çº¢)
            {
                radius: 34,
                fileName: 'å´”æ¢“ç’‡03.gif',
                score: 8,
                backgroundColor: '#FF6347',
                borderColor: '#DC143C'
            }, // 2 (ç•ªèŒ„çº¢/æ·±çº¢)
            {
                radius: 42,
                fileName: 'å´”æ¢“ç’‡04.gif',
                score: 16,
                backgroundColor: '#90EE90',
                borderColor: '#3CB371'
            }, // 3 (æµ…ç»¿/ä¸­ç­‰æµ·ç»¿)
            {
                radius: 52,
                fileName: 'å´”æ¢“ç’‡05.gif',
                score: 32,
                backgroundColor: '#32CD32',
                borderColor: '#228B22'
            }, // 4 (é²œç»¿/æ£®æ—ç»¿)
            {
                radius: 64,
                fileName: 'å´”æ¢“ç’‡06.gif',
                score: 64,
                backgroundColor: '#87CEFA',
                borderColor: '#4682B4'
            }, // 5 (æµ…è“/é’¢é’)
            {
                radius: 76,
                fileName: 'å´”æ¢“ç’‡07.gif',
                score: 128,
                backgroundColor: '#4169E1',
                borderColor: '#191970'
            }, // 6 (å®è“/åˆå¤œè“)
            {
                radius: 88,
                fileName: 'å´”æ¢“ç’‡08.gif',
                score: 256,
                backgroundColor: '#9932CC',
                borderColor: '#800080'
            }, // 7 (æ·±å…°èŠ±ç´«/ç´«)
            {
                radius: 100,
                fileName: 'å´”æ¢“ç’‡09.gif',
                score: 512,
                backgroundColor: '#FFD700',
                borderColor: '#B8860B'
            }, // 8 (é‡‘/æ·±é‡‘)
            {
                radius: 115,
                fileName: 'å´”æ¢“ç’‡10.gif',
                score: 1024,
                backgroundColor: '#C0C0C0',
                borderColor: '#808080'
            }, // 9 (é“¶/ç°)
            {
                radius: 135,
                fileName: 'å´”æ¢“ç’‡11.png',
                score: 2048,
                backgroundColor: '#228B22',
                borderColor: '#3CB371'
            } // 10: ç»ˆæ (ä¿æŒç»¿è‰²)
        ];

        // é¢„åŠ è½½ç³»ç»Ÿ
        // å­˜å‚¨ { url, scaleX, scaleY, loaded, imgObject }ï¼ŒimgObject æ˜¯å®é™…çš„ HTML Image å…ƒç´ 
        const textureCache = [];

        function preloadImages() {
            FRUIT_LEVELS.forEach((level, index) => {
                const img = new Image();
                const url = IMG_PATH + level.fileName;

                textureCache[index] = {
                    url: url,
                    scale: 1,
                    loaded: false,
                    imgObject: img // å­˜å‚¨å›¾ç‰‡å¯¹è±¡
                };

                img.onload = function() {
                    const diameter = level.radius * 2;
                    const scale = diameter / img.width;

                    textureCache[index].scale = scale;
                    textureCache[index].loaded = true;

                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.onerror = function() {
                    console.error("åŠ è½½å›¾ç‰‡å¤±è´¥:", url);
                    textureCache[index].loaded = false;
                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.src = url;
            });
        }

        preloadImages();


        // ===========================
        // Matter.js åˆå§‹åŒ–
        // ===========================
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            World = Matter.World,
            Events = Matter.Events,
            Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;

        const canvas = document.getElementById('world');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        let canvasWidth = canvasWrapper.clientWidth;
        let canvasHeight = canvasWrapper.clientHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvasWidth,
                height: canvasHeight,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });
        // è·å– Canvas 2D ä¸Šä¸‹æ–‡ï¼Œç”¨äºè‡ªå®šä¹‰ç»˜åˆ¶
        const context = render.context;


        // ===========================
        // æ¸¸æˆçŠ¶æ€å˜é‡
        // ===========================
        let currentFruit = null;
        let nextFruitLevel = 0;
        let score = 0;
        let isDropping = false;
        let isGameOver = false;
        const SPAWN_Y = 50;

        // ===========================
        // æ¸¸æˆè¾…åŠ©å‡½æ•°
        // ===========================

        function createWalls() {
            const wallThickness = 60;
            const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth + wallThickness * 2, wallThickness, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const leftWall = Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const rightWall = Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            World.add(world, [ground, leftWall, rightWall]);
        }

        /**
         * åˆ›å»ºæ°´æœåˆšä½“ã€‚ Matter.js çš„é»˜è®¤æ¸²æŸ“è¢«ç¦ç”¨ï¼Œæ”¹ä¸ºè‡ªå®šä¹‰æ¸²æŸ“ã€‚
         */
        function createFruitBody(x, y, levelIndex, isSensor = false) {
            const levelData = FRUIT_LEVELS[levelIndex];
            const textureData = textureCache[levelIndex];

            // è‡ªå®šä¹‰æ¸²æŸ“å±æ€§ï¼Œç”¨äºæ‰‹åŠ¨ç»˜åˆ¶
            const customRender = {
                level: levelIndex,
                texture: textureData, // åŒ…å« imgObject çš„ç¼“å­˜æ•°æ®
                backgroundColor: levelData.backgroundColor,
                borderColor: levelData.borderColor,
                radius: levelData.radius
            };

            const options = {
                isSensor: isSensor,
                isStatic: isSensor,
                restitution: 0.2,
                friction: 0.1,
                density: 0.002,
                label: 'fruit_' + levelIndex,
                render: {
                    visible: false // ç¦ç”¨ Matter.js é»˜è®¤æ¸²æŸ“
                },
                customRender: customRender // é™„åŠ è‡ªå®šä¹‰å±æ€§
            };

            return Bodies.circle(x, y, levelData.radius, options);
        }

        function getRandomNextLevel() {
            return Math.floor(Math.random() * 5);
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            const previewContainer = document.getElementById('next-item-preview');
            previewContainer.innerHTML = '';

            const textureData = textureCache[nextFruitLevel];
            const levelData = FRUIT_LEVELS[nextFruitLevel];

            // è®¾ç½®é¢„è§ˆæ¡†çš„èƒŒæ™¯å’Œæè¾¹
            previewContainer.style.backgroundColor = levelData.backgroundColor;
            previewContainer.style.borderColor = levelData.borderColor;

            if (textureData && textureData.loaded) {
                const img = new Image();
                img.src = textureData.url;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%'; // å°è¯•åœ¨UIé¢„è§ˆä¸­è£å‰ªä¸ºåœ†å½¢
                previewContainer.appendChild(img);
                previewContainer.style.color = 'transparent'; // å¦‚æœæœ‰å›¾ç‰‡ï¼Œæ–‡å­—ä¸å¯è§
            } else {
                // å¦‚æœå›¾ç‰‡æœªåŠ è½½ï¼Œæ˜¾ç¤ºç­‰çº§æ•°å­—
                previewContainer.innerText = (nextFruitLevel + 1).toString();
                previewContainer.style.color = 'white';
                previewContainer.style.fontWeight = 'bold';
                previewContainer.style.fontSize = '20px';
                previewContainer.style.display = 'flex';
                previewContainer.style.alignItems = 'center';
                previewContainer.style.justifyContent = 'center';
            }
        }

        function spawnCurrentFruit() {
            if (isGameOver) return;
            const level = nextFruitLevel;
            currentFruit = createFruitBody(canvasWidth / 2, SPAWN_Y, level, true);
            World.add(world, currentFruit);

            nextFruitLevel = getRandomNextLevel();
            updateUI();
            isDropping = false;
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('game-over-overlay').style.display = 'flex';
            if (currentFruit) World.remove(world, currentFruit);
        }

        // ===========================
        // è‡ªå®šä¹‰æ¸²æŸ“å‡½æ•° (åœ†å½¢è£å‰ªçš„å…³é”®)
        // ===========================
        function customRenderBodies() {
            // è·å–ä¸–ç•Œä¸­çš„æ‰€æœ‰åˆšä½“
            const bodies = Composite.allBodies(world);

            // è¿‡æ»¤å‡ºæˆ‘ä»¬è‡ªå®šä¹‰ç»˜åˆ¶çš„æ°´æœåˆšä½“
            const fruitBodies = bodies.filter(body => body.label.startsWith('fruit_') && body.customRender);

            fruitBodies.forEach(body => {
                const {
                    position,
                    angle,
                    customRender
                } = body;
                const {
                    texture,
                    backgroundColor,
                    borderColor,
                    radius
                } = customRender;

                // 1. ä¿å­˜å½“å‰ Canvas çŠ¶æ€
                context.save();

                // 2. ç§»åŠ¨å’Œæ—‹è½¬åˆ°åˆšä½“çš„ä½ç½®å’Œè§’åº¦
                context.translate(position.x, position.y);
                context.rotate(angle);

                // --- ç»˜åˆ¶åœ†å½¢èƒŒæ™¯å’Œæè¾¹ ---

                // 3. ç»˜åˆ¶åœ†å½¢è·¯å¾„ (ç”¨äºå¡«å……å’Œæè¾¹)
                context.beginPath();
                context.arc(0, 0, radius, 0, 2 * Math.PI);

                // 4. å¡«å……èƒŒæ™¯è‰²
                context.fillStyle = backgroundColor;
                context.fill();

                // 5. ç»˜åˆ¶æè¾¹
                context.lineWidth = 3;
                context.strokeStyle = borderColor;
                context.stroke();

                // --- è£å‰ªå¹¶ç»˜åˆ¶å›¾ç‰‡ ---

                if (texture && texture.loaded) {
                    // 6. åº”ç”¨è£å‰ªè’™ç‰ˆ (è·¯å¾„å·²ç»åœ¨æ­¥éª¤ 3 ä¸­å®šä¹‰)
                    context.clip();

                    // 7. ç»˜åˆ¶å›¾ç‰‡ (å›¾ç‰‡ä¼šè¢«è£å‰ªæˆåœ†å½¢)
                    const img = texture.imgObject;
                    const diameter = radius * 2;

                    // ç»˜åˆ¶å›¾ç‰‡ï¼Œä½¿å…¶å±…ä¸­å¹¶å¡«å……æ•´ä¸ªåœ†å½¢åŒºåŸŸ
                    context.drawImage(
                        img, -radius, // x åæ ‡ (-radius to center)
                        -radius, // y åæ ‡ (-radius to center)
                        diameter, // å®½åº¦
                        diameter // é«˜åº¦
                    );
                }

                // 8. æ¢å¤ Canvas çŠ¶æ€ (ç§»é™¤è£å‰ªå’Œè½¬æ¢)
                context.restore();
            });
        }

        // æŒ‚è½½åˆ° Matter.js æ¸²æŸ“å¾ªç¯çš„æœ«å°¾
        Events.on(render, 'afterRender', customRenderBodies);


        Events.on(engine, 'afterUpdate', function() {
            if (isGameOver || isDropping) return;

            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label.startsWith('fruit_') && !body.isSensor) {
                    // æ£€æŸ¥åˆšä½“æ˜¯å¦é•¿æ—¶é—´åœç•™åœ¨é¡¶éƒ¨
                    if (body.position.y < 80 && body.speed < 0.2 && body.position.y > 70) {
                        // ç¡®ä¿å®ƒç¡®å®åœ¨è¾¹ç•Œçº¿ä»¥ä¸Šåœç•™äº†ä¸€æ®µæ—¶é—´
                        if (!body.isStuck) {
                            body.isStuck = true;
                            body.stuckTimer = Date.now();
                        } else if (Date.now() - body.stuckTimer > 1000) { // åœç•™è¶…è¿‡ 1 ç§’
                            gameOver();
                            break;
                        }
                    } else {
                        body.isStuck = false;
                    }
                }
            }
        });


        // ===========================
        // æ ¸å¿ƒé€»è¾‘ï¼šç¢°æ’ä¸åˆå¹¶
        // ===========================
        Events.on(engine, 'collisionStart', function(event) {
            if (isGameOver) return;
            const pairs = event.pairs;

            const removedBodies = new Set();

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

                if (bodyA.label.startsWith('fruit_') && bodyB.label.startsWith('fruit_')) {
                    const levelA = parseInt(bodyA.label.split('_')[1]);
                    const levelB = parseInt(bodyB.label.split('_')[1]);

                    if (levelA === levelB && levelA < FRUIT_LEVELS.length - 1) {
                        removedBodies.add(bodyA.id);
                        removedBodies.add(bodyB.id);

                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        World.remove(world, [bodyA, bodyB]);

                        const newLevel = levelA + 1;
                        const newFruit = createFruitBody(midX, midY, newLevel);
                        World.add(world, newFruit);

                        score += FRUIT_LEVELS[newLevel].score;
                        document.getElementById('score').innerText = score;
                    }
                }
            }
        });


        // ===========================
        // è¾“å…¥äº‹ä»¶å¤„ç† (è§¦æ‘¸ä¸é¼ æ ‡)
        // ===========================
        function handleInputMove(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();

            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = canvas.getBoundingClientRect();
            let relativeX = clientX - rect.left;

            const currentLevel = parseInt(currentFruit.label.split('_')[1]);
            const radius = FRUIT_LEVELS[currentLevel].radius;
            relativeX = Math.max(radius, Math.min(canvasWidth - radius, relativeX));

            Matter.Body.setPosition(currentFruit, {
                x: relativeX,
                y: SPAWN_Y
            });
        }

        function handleInputEnd(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();
            isDropping = true;

            Matter.Body.setStatic(currentFruit, false);
            currentFruit.isSensor = false;
            currentFruit = null;

            setTimeout(spawnCurrentFruit, 600);
        }

        canvasWrapper.addEventListener('mousemove', handleInputMove);
        canvasWrapper.addEventListener('touchmove', handleInputMove, {
            passive: false
        });
        canvasWrapper.addEventListener('mouseup', handleInputEnd);
        canvasWrapper.addEventListener('touchend', handleInputEnd, {
            passive: false
        });
        canvasWrapper.addEventListener('click', handleInputEnd);

        document.getElementById('restart-btn').addEventListener('click', function() {
            // åœæ­¢è¿è¡Œ
            Runner.stop(runner);

            World.clear(world);
            Engine.clear(engine);
            score = 0;
            isGameOver = false;
            document.getElementById('game-over-overlay').style.display = 'none';
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            spawnCurrentFruit();

            // é‡æ–°è¿è¡Œ
            Runner.run(runner, engine);
        });


        // ===========================
        // å¯åŠ¨æ¸¸æˆ
        // ===========================
        let runner; // å°† runner è®¾ä¸ºå…¨å±€å˜é‡
        setTimeout(() => {
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            updateUI();
            spawnCurrentFruit();

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }, 100);

        window.addEventListener('resize', function() {
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            World.clear(world, true);
            createWalls();
        });
    </script>
</body>

</html>