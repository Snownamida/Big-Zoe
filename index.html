<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成崔梓璇</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS reset 和基础样式 */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* 禁止移动端长按选中文字和图片 */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* 禁止滚动 */
            background-color: #ffe4e1;
            /* 少女粉底色 */
            font-family: 'Arial', sans-serif;
            /* 柔和的背景渐变 */
            background-image: radial-gradient(circle at 50% 30%, #fff0f5 0%, #ffe4e1 80%);
        }
        /* 游戏主容器 */
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 500px;
            /*在大屏幕上限制最大宽度 */
            margin: 0 auto;
            background: transparent;
        }
        /* 顶部导航栏 */
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d63384;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .header-icons span {
            margin-left: 10px;
            cursor: pointer;
        }
        /* 游戏UI栏 (分数和下一个提示) */
        
        .game-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            color: #d63384;
            z-index: 10;
        }
        
        .score-box {
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .next-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .next-label {
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        /* 下一个提示的容器 */
        
        #next-item-preview {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 3px solid #fff;
            overflow: hidden;
            /* 确保图片不溢出 */
            box-shadow: 0 2px 10px rgba(214, 51, 132, 0.2);
        }
        
        #next-item-preview img {
            display: block;
            object-fit: contain;
        }
        /* Canvas 画布容器 */
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            margin-bottom: 10px;
            overflow: hidden;
            /* 容器边框 */
            border-left: 2px solid rgba(255, 255, 255, 0.5);
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
        }
        /* 实际的游戏画布 */
        
        #world {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* 游戏结束遮罩 */
        
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            color: #d63384;
            display: none;
            /* 默认隐藏 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #game-over-overlay h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #restart-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: #d63384;
            border: none;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4);
            transition: transform 0.1s;
        }
        
        #restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="header-bar">
            <div>合成崔梓璇</div>
            <div class="header-icons"><span>•••</span></div>
        </div>

        <div class="game-ui-bar">
            <div class="score-box"><span id="score">0</span></div>
            <div class="next-box">
                <span class="next-label">下一个:</span>
                <div id="next-item-preview">
                    <!-- 下一个提示图片将在这里显示 -->
                </div>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="world"></canvas>
            <div id="game-over-overlay">
                <h2>游戏结束</h2>
                <button id="restart-btn">再来一次</button>
            </div>
        </div>
    </div>


    <script>
        // ===========================
        // 游戏配置与素材定义
        // ===========================

        const IMG_PATH = 'images/';

        // 定义 11 个等级的属性，新增 backgroundColor 和 borderColor
        const FRUIT_LEVELS = [{
                radius: 18,
                fileName: '崔梓璇01.gif',
                score: 2,
                backgroundColor: '#FFFACD',
                borderColor: '#FFD700'
            }, // 0 (浅黄/金色)
            {
                radius: 26,
                fileName: '崔梓璇02.gif',
                score: 4,
                backgroundColor: '#FFA07A',
                borderColor: '#FF4500'
            }, // 1 (浅橙/橘红)
            {
                radius: 34,
                fileName: '崔梓璇03.gif',
                score: 8,
                backgroundColor: '#FF6347',
                borderColor: '#DC143C'
            }, // 2 (番茄红/深红)
            {
                radius: 42,
                fileName: '崔梓璇04.gif',
                score: 16,
                backgroundColor: '#90EE90',
                borderColor: '#3CB371'
            }, // 3 (浅绿/中等海绿)
            {
                radius: 52,
                fileName: '崔梓璇05.gif',
                score: 32,
                backgroundColor: '#32CD32',
                borderColor: '#228B22'
            }, // 4 (鲜绿/森林绿)
            {
                radius: 64,
                fileName: '崔梓璇06.gif',
                score: 64,
                backgroundColor: '#87CEFA',
                borderColor: '#4682B4'
            }, // 5 (浅蓝/钢青)
            {
                radius: 76,
                fileName: '崔梓璇07.gif',
                score: 128,
                backgroundColor: '#4169E1',
                borderColor: '#191970'
            }, // 6 (宝蓝/午夜蓝)
            {
                radius: 88,
                fileName: '崔梓璇08.gif',
                score: 256,
                backgroundColor: '#9932CC',
                borderColor: '#800080'
            }, // 7 (深兰花紫/紫)
            {
                radius: 100,
                fileName: '崔梓璇09.gif',
                score: 512,
                backgroundColor: '#FFD700',
                borderColor: '#B8860B'
            }, // 8 (金/深金)
            {
                radius: 115,
                fileName: '崔梓璇10.gif',
                score: 1024,
                backgroundColor: '#C0C0C0',
                borderColor: '#808080'
            }, // 9 (银/灰)
            {
                radius: 135,
                fileName: '崔梓璇11.png',
                score: 2048,
                backgroundColor: '#228B22',
                borderColor: '#3CB371'
            } // 10: 终极 (保持绿色)
        ];

        // 预加载系统
        // 存储 { url, scaleX, scaleY, loaded, imgObject }，imgObject 是实际的 HTML Image 元素
        const textureCache = [];

        function preloadImages() {
            FRUIT_LEVELS.forEach((level, index) => {
                const img = new Image();
                const url = IMG_PATH + level.fileName;

                textureCache[index] = {
                    url: url,
                    scale: 1,
                    loaded: false,
                    imgObject: img // 存储图片对象
                };

                img.onload = function() {
                    const diameter = level.radius * 2;
                    const scale = diameter / img.width;

                    textureCache[index].scale = scale;
                    textureCache[index].loaded = true;

                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.onerror = function() {
                    console.error("加载图片失败:", url);
                    textureCache[index].loaded = false;
                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.src = url;
            });
        }

        preloadImages();


        // ===========================
        // Matter.js 初始化
        // ===========================
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            World = Matter.World,
            Events = Matter.Events,
            Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;

        const canvas = document.getElementById('world');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        let canvasWidth = canvasWrapper.clientWidth;
        let canvasHeight = canvasWrapper.clientHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvasWidth,
                height: canvasHeight,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });
        // 获取 Canvas 2D 上下文，用于自定义绘制
        const context = render.context;


        // ===========================
        // 游戏状态变量
        // ===========================
        let currentFruit = null;
        let nextFruitLevel = 0;
        let score = 0;
        let isDropping = false;
        let isGameOver = false;
        const SPAWN_Y = 50;

        // ===========================
        // 游戏辅助函数
        // ===========================

        function createWalls() {
            const wallThickness = 60;
            const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth + wallThickness * 2, wallThickness, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const leftWall = Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const rightWall = Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            World.add(world, [ground, leftWall, rightWall]);
        }

        /**
         * 创建水果刚体。 Matter.js 的默认渲染被禁用，改为自定义渲染。
         */
        function createFruitBody(x, y, levelIndex, isSensor = false) {
            const levelData = FRUIT_LEVELS[levelIndex];
            const textureData = textureCache[levelIndex];

            // 自定义渲染属性，用于手动绘制
            const customRender = {
                level: levelIndex,
                texture: textureData, // 包含 imgObject 的缓存数据
                backgroundColor: levelData.backgroundColor,
                borderColor: levelData.borderColor,
                radius: levelData.radius
            };

            const options = {
                isSensor: isSensor,
                isStatic: isSensor,
                restitution: 0.2,
                friction: 0.1,
                density: 0.002,
                label: 'fruit_' + levelIndex,
                render: {
                    visible: false // 禁用 Matter.js 默认渲染
                },
                customRender: customRender // 附加自定义属性
            };

            return Bodies.circle(x, y, levelData.radius, options);
        }

        function getRandomNextLevel() {
            return Math.floor(Math.random() * 5);
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            const previewContainer = document.getElementById('next-item-preview');
            previewContainer.innerHTML = '';

            const textureData = textureCache[nextFruitLevel];
            const levelData = FRUIT_LEVELS[nextFruitLevel];

            // 设置预览框的背景和描边
            previewContainer.style.backgroundColor = levelData.backgroundColor;
            previewContainer.style.borderColor = levelData.borderColor;

            if (textureData && textureData.loaded) {
                const img = new Image();
                img.src = textureData.url;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%'; // 尝试在UI预览中裁剪为圆形
                previewContainer.appendChild(img);
                previewContainer.style.color = 'transparent'; // 如果有图片，文字不可见
            } else {
                // 如果图片未加载，显示等级数字
                previewContainer.innerText = (nextFruitLevel + 1).toString();
                previewContainer.style.color = 'white';
                previewContainer.style.fontWeight = 'bold';
                previewContainer.style.fontSize = '20px';
                previewContainer.style.display = 'flex';
                previewContainer.style.alignItems = 'center';
                previewContainer.style.justifyContent = 'center';
            }
        }

        function spawnCurrentFruit() {
            if (isGameOver) return;
            const level = nextFruitLevel;
            currentFruit = createFruitBody(canvasWidth / 2, SPAWN_Y, level, true);
            World.add(world, currentFruit);

            nextFruitLevel = getRandomNextLevel();
            updateUI();
            isDropping = false;
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('game-over-overlay').style.display = 'flex';
            if (currentFruit) World.remove(world, currentFruit);
        }

        // ===========================
        // 自定义渲染函数 (圆形裁剪的关键)
        // ===========================
        function customRenderBodies() {
            // 获取世界中的所有刚体
            const bodies = Composite.allBodies(world);

            // 过滤出我们自定义绘制的水果刚体
            const fruitBodies = bodies.filter(body => body.label.startsWith('fruit_') && body.customRender);

            fruitBodies.forEach(body => {
                const {
                    position,
                    angle,
                    customRender
                } = body;
                const {
                    texture,
                    backgroundColor,
                    borderColor,
                    radius
                } = customRender;

                // 1. 保存当前 Canvas 状态
                context.save();

                // 2. 移动和旋转到刚体的位置和角度
                context.translate(position.x, position.y);
                context.rotate(angle);

                // --- 绘制圆形背景和描边 ---

                // 3. 绘制圆形路径 (用于填充和描边)
                context.beginPath();
                context.arc(0, 0, radius, 0, 2 * Math.PI);

                // 4. 填充背景色
                context.fillStyle = backgroundColor;
                context.fill();

                // 5. 绘制描边
                context.lineWidth = 3;
                context.strokeStyle = borderColor;
                context.stroke();

                // --- 裁剪并绘制图片 ---

                if (texture && texture.loaded) {
                    // 6. 应用裁剪蒙版 (路径已经在步骤 3 中定义)
                    context.clip();

                    // 7. 绘制图片 (图片会被裁剪成圆形)
                    const img = texture.imgObject;
                    const diameter = radius * 2;

                    // 绘制图片，使其居中并填充整个圆形区域
                    context.drawImage(
                        img, -radius, // x 坐标 (-radius to center)
                        -radius, // y 坐标 (-radius to center)
                        diameter, // 宽度
                        diameter // 高度
                    );
                }

                // 8. 恢复 Canvas 状态 (移除裁剪和转换)
                context.restore();
            });
        }

        // 挂载到 Matter.js 渲染循环的末尾
        Events.on(render, 'afterRender', customRenderBodies);


        Events.on(engine, 'afterUpdate', function() {
            if (isGameOver || isDropping) return;

            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label.startsWith('fruit_') && !body.isSensor) {
                    // 检查刚体是否长时间停留在顶部
                    if (body.position.y < 80 && body.speed < 0.2 && body.position.y > 70) {
                        // 确保它确实在边界线以上停留了一段时间
                        if (!body.isStuck) {
                            body.isStuck = true;
                            body.stuckTimer = Date.now();
                        } else if (Date.now() - body.stuckTimer > 1000) { // 停留超过 1 秒
                            gameOver();
                            break;
                        }
                    } else {
                        body.isStuck = false;
                    }
                }
            }
        });


        // ===========================
        // 核心逻辑：碰撞与合并
        // ===========================
        Events.on(engine, 'collisionStart', function(event) {
            if (isGameOver) return;
            const pairs = event.pairs;

            const removedBodies = new Set();

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

                if (bodyA.label.startsWith('fruit_') && bodyB.label.startsWith('fruit_')) {
                    const levelA = parseInt(bodyA.label.split('_')[1]);
                    const levelB = parseInt(bodyB.label.split('_')[1]);

                    if (levelA === levelB && levelA < FRUIT_LEVELS.length - 1) {
                        removedBodies.add(bodyA.id);
                        removedBodies.add(bodyB.id);

                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        World.remove(world, [bodyA, bodyB]);

                        const newLevel = levelA + 1;
                        const newFruit = createFruitBody(midX, midY, newLevel);
                        World.add(world, newFruit);

                        score += FRUIT_LEVELS[newLevel].score;
                        document.getElementById('score').innerText = score;
                    }
                }
            }
        });


        // ===========================
        // 输入事件处理 (触摸与鼠标)
        // ===========================
        function handleInputMove(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();

            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = canvas.getBoundingClientRect();
            let relativeX = clientX - rect.left;

            const currentLevel = parseInt(currentFruit.label.split('_')[1]);
            const radius = FRUIT_LEVELS[currentLevel].radius;
            relativeX = Math.max(radius, Math.min(canvasWidth - radius, relativeX));

            Matter.Body.setPosition(currentFruit, {
                x: relativeX,
                y: SPAWN_Y
            });
        }

        function handleInputEnd(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();
            isDropping = true;

            Matter.Body.setStatic(currentFruit, false);
            currentFruit.isSensor = false;
            currentFruit = null;

            setTimeout(spawnCurrentFruit, 600);
        }

        canvasWrapper.addEventListener('mousemove', handleInputMove);
        canvasWrapper.addEventListener('touchmove', handleInputMove, {
            passive: false
        });
        canvasWrapper.addEventListener('mouseup', handleInputEnd);
        canvasWrapper.addEventListener('touchend', handleInputEnd, {
            passive: false
        });
        canvasWrapper.addEventListener('click', handleInputEnd);

        document.getElementById('restart-btn').addEventListener('click', function() {
            // 停止运行
            Runner.stop(runner);

            World.clear(world);
            Engine.clear(engine);
            score = 0;
            isGameOver = false;
            document.getElementById('game-over-overlay').style.display = 'none';
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            spawnCurrentFruit();

            // 重新运行
            Runner.run(runner, engine);
        });


        // ===========================
        // 启动游戏
        // ===========================
        let runner; // 将 runner 设为全局变量
        setTimeout(() => {
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            updateUI();
            spawnCurrentFruit();

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }, 100);

        window.addEventListener('resize', function() {
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            World.clear(world, true);
            createWalls();
        });
    </script>
</body>

</html>