<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¼¹å°„å´”æ¢“ç’‡</title>
    <link rel="icon" href="images/å´”æ¢“ç’‡01.gif" type="image/gif">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS reset å’ŒåŸºç¡€æ ·å¼ */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #ffe4e1;
            font-family: 'Arial', sans-serif;
            background-image: radial-gradient(circle at 50% 30%, #fff0f5 0%, #ffe4e1 80%);
        }
        /* æ¸¸æˆä¸»å®¹å™¨ */
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            background: transparent;
        }
        /* é¡¶éƒ¨å¯¼èˆªæ  (ä¿®æ”¹ä¸ºé“¾æ¥åˆ°åŸç‰ˆæ¸¸æˆ) */
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d63384;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .header-bar a {
            text-decoration: none;
        }
        
        .header-bar button {
            background: #ff69b4;
            color: white;
            border: 2px solid #fff;
            border-radius: 15px;
            padding: 5px 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(214, 51, 132, 0.2);
        }
        /* æ¸¸æˆUIæ  (åˆ†æ•°å’Œå‰©ä½™å¼¹è¯) */
        
        .game-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            /* å±…ä¸­å¯¹é½ */
            padding: 10px 20px;
            color: #d63384;
            z-index: 10;
        }
        
        .score-box,
        .ammo-box {
            font-size: 20px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .ammo-box {
            font-size: 16px;
        }
        /* Canvas ç”»å¸ƒå®¹å™¨ */
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            margin-bottom: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-top: none;
            /* ç§»é™¤é¡¶éƒ¨è¾¹æ¡† */
        }
        /* å®é™…çš„æ¸¸æˆç”»å¸ƒ */
        
        #world {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* æ¸¸æˆç»“æŸ/å…³å¡ç»“æŸ é®ç½© */
        
        #end-level-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            color: #d63384;
            display: none;
            /* é»˜è®¤éšè— */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            text-align: center;
        }
        
        #end-level-overlay h2 {
            font-size: 32px;
            margin-bottom: 15px;
        }
        
        #end-level-overlay p {
            font-size: 18px;
            margin-bottom: 25px;
        }
        
        #end-level-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: #d63384;
            border: none;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4);
            transition: transform 0.1s;
        }
        
        #end-level-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="header-bar">
            <div>å¼¹å°„å´”æ¢“ç’‡</div>
            <a href="suika.html"> <button>å»ç©åˆæˆå´”æ¢“ç’‡ ğŸ‘‰</button>
            </a>
        </div>

        <div class="game-ui-bar">
            <div class="score-box">åˆ†æ•°: <span id="score">0</span></div>
            <div class="ammo-box">å…³å¡: <span id="level">1</span></div>
            <div class="ammo-box">å‰©ä½™: <span id="ammo">0</span></div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="world"></canvas>
            <div id="end-level-overlay">
                <h2 id="end-level-title">å…³å¡å®Œæˆ!</h2>
                <p id="end-level-score">ä½ çš„åˆ†æ•°: 0</p>
                <button id="end-level-btn">ä¸‹ä¸€å…³</button>
            </div>
        </div>
    </div>


    <script>
        // ===========================
        // æ¸¸æˆé…ç½®ä¸ç´ æå®šä¹‰
        // ===========================

        const IMG_PATH = 'images/';

        // å®šä¹‰ 11 ä¸ªç­‰çº§çš„å±æ€§ (åŸç‰ˆç´ æ)
        // æˆ‘ä»¬å°†ç”¨ 0 ä½œä¸º projectile, 1-10 ä½œä¸º targets
        const FRUIT_LEVELS = [{
                radius: 18,
                fileName: 'å´”æ¢“ç’‡01.gif',
                score: 100, // å‡»ä¸­åŸºç¡€åˆ†
                mass: 1.5,
                backgroundColor: '#FFFACD',
                borderColor: '#FFD700'
            }, // 0: Projectile
            {
                radius: 24,
                fileName: 'å´”æ¢“ç’‡02.gif',
                score: 500,
                mass: 1,
                backgroundColor: '#FFA07A',
                borderColor: '#FF4500'
            }, // 1: Target 1
            {
                radius: 30,
                fileName: 'å´”æ¢“ç’‡03.gif',
                score: 800,
                mass: 1.5,
                backgroundColor: '#FF6347',
                borderColor: '#DC143C'
            }, // 2: Target 2
            {
                radius: 34,
                fileName: 'å´”æ¢“ç’‡04.gif',
                score: 1000,
                mass: 2,
                backgroundColor: '#90EE90',
                borderColor: '#3CB371'
            }, // 3
            {
                radius: 42,
                fileName: 'å´”æ¢“ç’‡05.gif',
                score: 1500,
                mass: 2.5,
                backgroundColor: '#32CD32',
                borderColor: '#228B22'
            }, // 4
            {
                radius: 52,
                fileName: 'å´”æ¢“ç’‡06.gif',
                score: 2000,
                mass: 3,
                backgroundColor: '#87CEFA',
                borderColor: '#4682B4'
            }, // 5
            {
                radius: 64,
                fileName: 'å´”æ¢“ç’‡07.gif',
                score: 2500,
                mass: 4,
                backgroundColor: '#4169E1',
                borderColor: '#191970'
            }, // 6
            {
                radius: 76,
                fileName: 'å´”æ¢“ç’‡08.gif',
                score: 3000,
                mass: 5,
                backgroundColor: '#9932CC',
                borderColor: '#800080'
            }, // 7
            {
                radius: 88,
                fileName: 'å´”æ¢“ç’‡09.gif',
                score: 4000,
                mass: 6,
                backgroundColor: '#FFD700',
                borderColor: '#B8860B'
            }, // 8
            {
                radius: 100,
                fileName: 'å´”æ¢“ç’‡10.gif',
                score: 5000,
                mass: 8,
                backgroundColor: '#C0C0C0',
                borderColor: '#808080'
            }, // 9
            {
                radius: 115,
                fileName: 'å´”æ¢“ç’‡11.png',
                score: 10000,
                mass: 15,
                backgroundColor: '#228B22',
                borderColor: '#3CB371'
            } // 10: "Boss" Target
        ];

        // é¢„åŠ è½½ç³»ç»Ÿ (å¤ç”¨åŸç‰ˆ)
        const textureCache = [];

        function preloadImages() {
            let loadedCount = 0;
            const totalCount = FRUIT_LEVELS.length;
            return new Promise((resolve) => {
                FRUIT_LEVELS.forEach((level, index) => {
                    const img = new Image();
                    const url = IMG_PATH + level.fileName;

                    textureCache[index] = {
                        url: url,
                        scale: 1,
                        loaded: false,
                        imgObject: img
                    };

                    img.onload = function() {
                        const diameter = level.radius * 2;
                        textureCache[index].scale = diameter / img.width;
                        textureCache[index].loaded = true;
                        loadedCount++;
                        if (loadedCount === totalCount) {
                            resolve();
                        }
                    };
                    img.onerror = function() {
                        console.error("åŠ è½½å›¾ç‰‡å¤±è´¥:", url);
                        textureCache[index].loaded = false; // æ ‡è®°ä¸ºæœªåŠ è½½
                        loadedCount++;
                        if (loadedCount === totalCount) {
                            resolve(); // å³ä½¿å¤±è´¥ä¹Ÿç»§ç»­
                        }
                    };
                    img.src = url;
                });
            });
        }


        // ===========================
        // Matter.js åˆå§‹åŒ–
        // ===========================
        const {
            Engine,
            Render,
            Runner,
            Bodies,
            World,
            Events,
            Composite,
            Constraint,
            Mouse,
            MouseConstraint
        } = Matter;

        const engine = Engine.create();
        const world = engine.world;
        engine.world.gravity.y = 1; // æ ‡å‡†é‡åŠ›

        const canvas = document.getElementById('world');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        let canvasWidth = canvasWrapper.clientWidth;
        let canvasHeight = canvasWrapper.clientHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvasWidth,
                height: canvasHeight,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });
        const context = render.context;
        let runner;

        // ===========================
        // å…³å¡å®šä¹‰
        // ===========================
        const LEVELS = [
            // å…³å¡ 1
            {
                ammo: 3,
                targets: [{
                        x: 0.7,
                        y: 0.8,
                        level: 1
                    }, // level 1 = å´”æ¢“ç’‡02.gif
                ],
                blocks: [{
                    x: 0.7,
                    y: 0.9,
                    w: 100,
                    h: 20
                }, ]
            },
            // å…³å¡ 2
            {
                ammo: 4,
                targets: [{
                        x: 0.65,
                        y: 0.8,
                        level: 1
                    }, {
                        x: 0.75,
                        y: 0.8,
                        level: 2
                    }, // level 2 = å´”æ¢“ç’‡03.gif
                ],
                blocks: [{
                    x: 0.7,
                    y: 0.9,
                    w: 150,
                    h: 20
                }, {
                    x: 0.7,
                    y: 0.7,
                    w: 150,
                    h: 20
                }, ]
            },
            // å…³å¡ 3
            {
                ammo: 5,
                targets: [{
                        x: 0.7,
                        y: 0.5,
                        level: 3
                    }, // level 3 = å´”æ¢“ç’‡04.gif
                    {
                        x: 0.6,
                        y: 0.8,
                        level: 1
                    }, {
                        x: 0.8,
                        y: 0.8,
                        level: 1
                    },
                ],
                blocks: [{
                    x: 0.7,
                    y: 0.9,
                    w: 250,
                    h: 20
                }, {
                    x: 0.6,
                    y: 0.7,
                    w: 80,
                    h: 20
                }, {
                    x: 0.8,
                    y: 0.7,
                    w: 80,
                    h: 20
                }, {
                    x: 0.7,
                    y: 0.6,
                    w: 80,
                    h: 20
                }, ]
            },
            // å…³å¡ 4
            {
                ammo: 3,
                targets: [{
                        x: 0.75,
                        y: 0.8,
                        level: 10
                    }, // level 10 = å´”æ¢“ç’‡11.png (Boss)
                ],
                blocks: [{
                    x: 0.75,
                    y: 0.9,
                    w: 250,
                    h: 20
                }, ]
            },
        ];

        // ===========================
        // æ¸¸æˆçŠ¶æ€å˜é‡
        // ===========================
        let currentProjectile = null;
        let slingshotConstraint = null;
        let score = 0;
        let currentLevelIndex = 0;
        let ammo = 0;
        let isAiming = false;
        let isGameOver = false;
        let projectileLaunched = false;
        const scoredTargets = new Set(); // å­˜å‚¨å·²è®¡åˆ†çš„ target ID

        // å¼¹å¼“ä½ç½® (ç›¸å¯¹äºç”»å¸ƒç™¾åˆ†æ¯”)
        const SLINGSHOT_POS = {
            x: 0.2,
            y: 0.75
        };
        let slingshotX, slingshotY;

        // ===========================
        // æ¸¸æˆè¾…åŠ©å‡½æ•°
        // ===========================

        function updateSlingshotPosition() {
            slingshotX = canvasWidth * SLINGSHOT_POS.x;
            slingshotY = canvasHeight * SLINGSHOT_POS.y;
        }

        function createWalls() {
            const wallThickness = 100;
            const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth, wallThickness, {
                isStatic: true,
                label: 'ground',
                render: {
                    fillStyle: '#E0BBE4'
                } // å¯è§åœ°é¢
            });
            const leftWall = Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                label: 'wall_left',
                render: {
                    visible: false
                }
            });
            const rightWall = Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                label: 'wall_right',
                render: {
                    visible: false
                }
            });
            World.add(world, [ground, leftWall, rightWall]);
        }

        /**
         * åˆ›å»ºå´”æ¢“ç’‡åˆšä½“ (å¤ç”¨å¹¶ä¿®æ”¹)
         */
        function createFruitBody(x, y, levelIndex, label) {
            const levelData = FRUIT_LEVELS[levelIndex];
            const textureData = textureCache[levelIndex];

            const customRender = {
                level: levelIndex,
                texture: textureData,
                backgroundColor: levelData.backgroundColor,
                borderColor: levelData.borderColor,
                radius: levelData.radius,
                score: levelData.score // é™„åŠ åˆ†æ•°
            };

            const options = {
                restitution: 0.4,
                friction: 0.1,
                density: levelData.mass / (levelData.radius * levelData.radius), // æ ¹æ®è´¨é‡å’ŒåŠå¾„è®¡ç®—å¯†åº¦
                label: label,
                render: {
                    visible: false
                }, // ç¦ç”¨é»˜è®¤æ¸²æŸ“
                customRender: customRender
            };

            return Bodies.circle(x, y, levelData.radius, options);
        }

        /**
         * åˆ›å»ºéšœç¢ç‰©
         */
        function createBlock(x, y, w, h) {
            return Bodies.rectangle(x, y, w, h, {
                friction: 0.4,
                restitution: 0.2,
                density: 0.005,
                label: 'block',
                render: {
                    visible: false
                }, // ç¦ç”¨é»˜è®¤æ¸²æŸ“
                customRender: { // è‡ªå®šä¹‰æ¸²æŸ“å±æ€§
                    width: w,
                    height: h,
                    color: '#8B4513' // æ£•è‰²
                }
            });
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            document.getElementById('level').innerText = currentLevelIndex + 1;
            document.getElementById('ammo').innerText = ammo;
        }

        /**
         * åŠ è½½æ–°å…³å¡
         */
        function setupLevel(levelIndex) {
            isGameOver = false;
            projectileLaunched = false;
            scoredTargets.clear();
            World.clear(world, false); // æ¸…ç†åˆšä½“ï¼Œä¿ç•™çº¦æŸ (è™½ç„¶è¿™é‡Œä¹Ÿæ¸…äº†)
            Engine.clear(engine);

            createWalls();
            updateSlingshotPosition();

            const level = LEVELS[levelIndex];
            if (!level) {
                showEndScreen(true, true); // æ‰€æœ‰å…³å¡å®Œæˆ
                return;
            }

            ammo = level.ammo;

            // æ·»åŠ  targets
            level.targets.forEach(t => {
                const x = t.x * canvasWidth;
                const y = t.y * canvasHeight;
                World.add(world, createFruitBody(x, y, t.level, 'target_' + t.level));
            });

            // æ·»åŠ  blocks
            level.blocks.forEach(b => {
                const x = b.x * canvasWidth;
                const y = b.y * canvasHeight;
                World.add(world, createBlock(x, y, b.w, b.h));
            });

            updateUI();
            spawnProjectile();
        }

        /**
         * ç”Ÿæˆå¾…å‘å°„çš„å¼¹ä¸¸
         */
        function spawnProjectile() {
            if (ammo <= 0 || isGameOver) return;
            ammo--;
            updateUI();

            projectileLaunched = false;
            currentProjectile = createFruitBody(slingshotX, slingshotY, 0, 'projectile_0'); // 0çº§ = å´”æ¢“ç’‡01

            slingshotConstraint = Constraint.create({
                pointA: {
                    x: slingshotX,
                    y: slingshotY
                },
                bodyB: currentProjectile,
                stiffness: 0.05,
                damping: 0.01,
                render: {
                    visible: false
                } // æˆ‘ä»¬å°†è‡ªå®šä¹‰ç»˜åˆ¶å¼¹å¼“
            });

            World.add(world, [currentProjectile, slingshotConstraint]);
        }

        /**
         * æ˜¾ç¤ºç»“æŸç”»é¢ (æ¸¸æˆç»“æŸæˆ–å…³å¡èƒœåˆ©)
         */
        function showEndScreen(isWin, isAllLevelsComplete = false) {
            isGameOver = true;
            const overlay = document.getElementById('end-level-overlay');
            const title = document.getElementById('end-level-title');
            const scoreText = document.getElementById('end-level-score');
            const button = document.getElementById('end-level-btn');

            if (isAllLevelsComplete) {
                title.innerText = "æ­å–œé€šå…³!";
                scoreText.innerText = "æ€»åˆ†æ•°: " + score;
                button.innerText = "é‡æ–°å¼€å§‹";
            } else if (isWin) {
                title.innerText = "å…³å¡å®Œæˆ!";
                scoreText.innerText = "å½“å‰åˆ†æ•°: " + score;
                button.innerText = "ä¸‹ä¸€å…³";
            } else {
                title.innerText = "æ¸¸æˆç»“æŸ";
                scoreText.innerText = "å½“å‰åˆ†æ•°: " + score;
                button.innerText = "å†è¯•ä¸€æ¬¡";
            }

            overlay.style.display = 'flex';
        }

        /**
         * æ£€æŸ¥èƒœåˆ©æˆ–å¤±è´¥æ¡ä»¶
         */
        function checkWinLoss() {
            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ targets
            const targets = Composite.allBodies(world).filter(b => b.label.startsWith('target_'));

            if (targets.length === 0) {
                // èƒœåˆ©
                showEndScreen(true);
            } else if (ammo === 0) {
                // å¤±è´¥
                showEndScreen(false);
            } else {
                // ç»§ç»­
                setTimeout(spawnProjectile, 1000); // 1ç§’åç”Ÿæˆä¸‹ä¸€ä¸ª
            }
        }

        // ===========================
        // è‡ªå®šä¹‰æ¸²æŸ“å‡½æ•° (åœ†å½¢è£å‰ªçš„å…³é”®)
        // ===========================
        function customRenderBodies() {
            const bodies = Composite.allBodies(world);

            // ç»˜åˆ¶å¼¹å¼“
            context.save();
            // ç»˜åˆ¶å¼¹å¼“åº•åº§
            context.beginPath();
            context.arc(slingshotX, slingshotY + 10, 15, 0, 2 * Math.PI);
            context.fillStyle = 'rgba(139, 69, 19, 0.7)'; // æ£•è‰²
            context.fill();
            context.lineWidth = 3;
            context.strokeStyle = '#654321';
            context.stroke();

            // ç»˜åˆ¶å¼¹å¼“çš®ç­‹
            if (isAiming && currentProjectile) {
                context.beginPath();
                context.moveTo(slingshotX - 10, slingshotY); // å·¦æ”¯ç‚¹
                context.lineTo(currentProjectile.position.x, currentProjectile.position.y);
                context.moveTo(slingshotX + 10, slingshotY); // å³æ”¯ç‚¹
                context.lineTo(currentProjectile.position.x, currentProjectile.position.y);
                context.strokeStyle = '#333';
                context.lineWidth = 4;
                context.stroke();
            }
            context.restore();


            // éå†æ‰€æœ‰åˆšä½“
            bodies.forEach(body => {
                context.save();
                context.translate(body.position.x, body.position.y);
                context.rotate(body.angle);

                if (body.label.startsWith('fruit_') || body.label.startsWith('projectile_') || body.label.startsWith('target_')) {
                    // --- ç»˜åˆ¶ å´”æ¢“ç’‡ (åœ†å½¢) ---
                    const {
                        texture,
                        backgroundColor,
                        borderColor,
                        radius
                    } = body.customRender;

                    context.beginPath();
                    context.arc(0, 0, radius, 0, 2 * Math.PI);
                    context.fillStyle = backgroundColor;
                    context.fill();
                    context.lineWidth = 3;
                    context.strokeStyle = borderColor;
                    context.stroke();

                    if (texture && texture.loaded) {
                        context.clip(); // åº”ç”¨è£å‰ª
                        const img = texture.imgObject;
                        const diameter = radius * 2;
                        context.drawImage(img, -radius, -radius, diameter, diameter);
                    }
                } else if (body.label === 'block') {
                    // --- ç»˜åˆ¶ éšœç¢ç‰© (çŸ©å½¢) ---
                    const {
                        width,
                        height,
                        color
                    } = body.customRender;
                    context.beginPath();
                    context.rect(-width / 2, -height / 2, width, height);
                    context.fillStyle = color;
                    context.fill();
                    context.lineWidth = 2;
                    context.strokeStyle = '#654321'; // æ·±æ£•è‰²è¾¹æ¡†
                    context.stroke();
                }

                context.restore();
            });
        }
        Events.on(render, 'afterRender', customRenderBodies);


        // ===========================
        // æ ¸å¿ƒé€»è¾‘ï¼šç¢°æ’
        // ===========================
        Events.on(engine, 'collisionStart', function(event) {
            if (isGameOver) return;
            const pairs = event.pairs;

            pairs.forEach(pair => {
                const {
                    bodyA,
                    bodyB
                } = pair;
                let target = null;
                let other = null;

                if (bodyA.label.startsWith('target_')) {
                    target = bodyA;
                    other = bodyB;
                } else if (bodyB.label.startsWith('target_')) {
                    target = bodyB;
                    other = bodyA;
                }

                if (target && !scoredTargets.has(target.id)) {
                    // åªè¦ target è¢«æ’äº† (æ— è®ºæ˜¯è¢«å¼¹ä¸¸ã€æ–¹å—è¿˜æ˜¯åœ°é¢)
                    const impulse = pair.collision.impulse.x + pair.collision.impulse.y;

                    // åªæœ‰ä¸€å®šåŠ›åº¦çš„æ’å‡»æ‰è®¡åˆ†å’Œç§»é™¤
                    if (impulse > 1.5 || other.label.startsWith('projectile_')) {
                        // æ’­æ”¾éŸ³æ•ˆæˆ–åŠ¨ç”»çš„åœ°æ–¹

                        // è®¡åˆ†
                        score += target.customRender.score;
                        scoredTargets.add(target.id);
                        updateUI();

                        // å»¶è¿Ÿç§»é™¤ï¼Œç»™ç©å®¶ä¸€ä¸ªè§†è§‰åé¦ˆ
                        setTimeout(() => {
                            // æ£€æŸ¥åˆšä½“æ˜¯å¦è¿˜å­˜åœ¨ (é˜²æ­¢é‡å¤ç§»é™¤)
                            if (Composite.get(world, target.id, 'body')) {
                                World.remove(world, target);
                            }
                        }, 100);
                    }
                }
            });
        });

        // ===========================
        // æ ¸å¿ƒé€»è¾‘ï¼šæ¸¸æˆå¾ªç¯
        // ===========================
        Events.on(engine, 'afterUpdate', function() {
            if (isGameOver) return;

            // æ£€æŸ¥å¼¹ä¸¸æ˜¯å¦å·²åœæ­¢
            if (projectileLaunched && currentProjectile) {
                const isOffScreen = currentProjectile.position.y > canvasHeight + 50 ||
                    currentProjectile.position.x < -50 ||
                    currentProjectile.position.x > canvasWidth + 50;

                const isResting = currentProjectile.speed < 0.5 && currentProjectile.angularSpeed < 0.1;

                // åœ¨é™æ­¢ 1.5 ç§’åæˆ–é£å‡ºå±å¹•åï¼Œæ£€æŸ¥èƒœè´Ÿ
                if (isOffScreen || (isResting && !currentProjectile.restingTimer)) {
                    currentProjectile.restingTimer = Date.now();
                } else if (isResting && (Date.now() - currentProjectile.restingTimer > 1500)) {
                    World.remove(world, currentProjectile);
                    currentProjectile = null;
                    projectileLaunched = false;
                    checkWinLoss();
                }
            }
        });


        // ===========================
        // è¾“å…¥äº‹ä»¶å¤„ç† (é¼ æ ‡ä¸è§¦æ‘¸)
        // ===========================
        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                stiffness: 0.2,
                render: {
                    visible: false
                }
            }
        });

        Events.on(mouseConstraint, 'startdrag', (e) => {
            if (e.body === currentProjectile) {
                isAiming = true;
            }
        });

        Events.on(mouseConstraint, 'enddrag', (e) => {
            if (e.body === currentProjectile && isAiming) {
                isAiming = false;
                projectileLaunched = true;
                if (slingshotConstraint) {
                    World.remove(world, slingshotConstraint);
                    slingshotConstraint = null;
                }
            }
        });

        Events.on(mouseConstraint, 'mousemove', (e) => {
            if (isAiming && currentProjectile) {
                // é™åˆ¶æ‹–æ‹½è·ç¦»
                const dx = e.mouse.position.x - slingshotX;
                const dy = e.mouse.position.y - slingshotY;
                const maxDist = 100;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > maxDist) {
                    const ratio = maxDist / dist;
                    Matter.Body.setPosition(currentProjectile, {
                        x: slingshotX + dx * ratio,
                        y: slingshotY + dy * ratio
                    });
                }
            }
        });

        World.add(world, mouseConstraint);
        render.mouse = mouse; // ç¡®ä¿æ¸²æŸ“å™¨çŸ¥é“é¼ æ ‡

        // ç»“æŸç”»é¢æŒ‰é’®
        document.getElementById('end-level-btn').addEventListener('click', function() {
            const overlay = document.getElementById('end-level-overlay');
            overlay.style.display = 'none';

            if (this.innerText === "ä¸‹ä¸€å…³") {
                currentLevelIndex++;
                setupLevel(currentLevelIndex);
            } else if (this.innerText === "å†è¯•ä¸€æ¬¡") {
                setupLevel(currentLevelIndex);
            } else if (this.innerText === "é‡æ–°å¼€å§‹") {
                currentLevelIndex = 0;
                score = 0;
                setupLevel(currentLevelIndex);
            }
        });


        // ===========================
        // å¯åŠ¨æ¸¸æˆ
        // ===========================
        function initGame() {
            // ç¡®ä¿ DOM åŠ è½½å®Œæˆ
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            render.options.width = canvasWidth;
            render.options.height = canvasHeight;

            score = 0;
            currentLevelIndex = 0;

            setupLevel(currentLevelIndex);

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }

        // é¢„åŠ è½½å›¾ç‰‡ï¼Œç„¶åå¯åŠ¨æ¸¸æˆ
        preloadImages().then(() => {
            // ç¡®ä¿åœ¨ DOM å®Œå…¨åŠ è½½åå†åˆå§‹åŒ–
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initGame);
            } else {
                initGame();
            }
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', function() {
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            render.options.width = canvasWidth;
            render.options.height = canvasHeight;

            // é‡æ–°è®¾ç½®å¢™å£å’Œå¼¹å¼“ä½ç½®å¹¶é‡è½½å…³å¡
            console.log("Resizing... reloading level.");
            setupLevel(currentLevelIndex);
        });
    </script>
</body>

</html>