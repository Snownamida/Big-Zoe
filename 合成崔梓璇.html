<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成崔梓璇</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS reset 和基础样式 */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* 禁止移动端长按选中文字和图片 */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* 禁止滚动 */
            background-color: #ffe4e1;
            /* 少女粉底色 */
            font-family: 'Arial', sans-serif;
            /* 柔和的背景渐变 */
            background-image: radial-gradient(circle at 50% 30%, #fff0f5 0%, #ffe4e1 80%);
        }
        /* 游戏主容器 */
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 500px;
            /*在大屏幕上限制最大宽度 */
            margin: 0 auto;
            background: transparent;
        }
        /* 顶部导航栏 */
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d63384;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .header-icons span {
            margin-left: 10px;
            cursor: pointer;
        }
        /* 游戏UI栏 (分数和下一个提示) */
        
        .game-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            color: #d63384;
            z-index: 10;
        }
        
        .score-box {
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .next-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .next-label {
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        /* 下一个提示的容器 */
        
        #next-item-preview {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 3px solid #fff;
            overflow: hidden;
            /* 确保图片不溢出 */
            box-shadow: 0 2px 10px rgba(214, 51, 132, 0.2);
        }
        
        #next-item-preview img {
            display: block;
            object-fit: contain;
        }
        /* Canvas 画布容器 */
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            margin-bottom: 10px;
            overflow: hidden;
            /* 容器边框 */
            border-left: 2px solid rgba(255, 255, 255, 0.5);
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
        }
        /* 实际的游戏画布 */
        
        #world {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* 游戏结束遮罩 */
        
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            color: #d63384;
            display: none;
            /* 默认隐藏 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #game-over-overlay h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #restart-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: #d63384;
            border: none;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4);
            transition: transform 0.1s;
        }
        
        #restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="header-bar">
            <div>合成崔梓璇</div>
            <div class="header-icons"><span>•••</span></div>
        </div>

        <div class="game-ui-bar">
            <div class="score-box"><span id="score">0</span></div>
            <div class="next-box">
                <span class="next-label">下一个:</span>
                <div id="next-item-preview">
                    <!-- 下一个提示图片将在这里显示 -->
                </div>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="world"></canvas>
            <div id="game-over-overlay">
                <h2>游戏结束</h2>
                <button id="restart-btn">再来一次</button>
            </div>
        </div>
    </div>


    <script>
        // ===========================
        // 游戏配置与素材定义
        // ===========================

        const IMG_PATH = 'images/';

        // 定义 11 个等级的属性，新增 backgroundColor 和 borderColor
        const FRUIT_LEVELS = [{
                radius: 18,
                fileName: '崔梓璇01.gif',
                score: 2,
                backgroundColor: '#FFB6C1',
                borderColor: '#F08080'
            }, // 0
            {
                radius: 26,
                fileName: '崔梓璇02.gif',
                score: 4,
                backgroundColor: '#FF69B4',
                borderColor: '#FF1493'
            }, // 1
            {
                radius: 34,
                fileName: '崔梓璇03.gif',
                score: 8,
                backgroundColor: '#FF1493',
                borderColor: '#C71585'
            }, // 2
            {
                radius: 42,
                fileName: '崔梓璇04.gif',
                score: 16,
                backgroundColor: '#DB7093',
                borderColor: '#CD5C5C'
            }, // 3
            {
                radius: 52,
                fileName: '崔梓璇05.gif',
                score: 32,
                backgroundColor: '#C71585',
                borderColor: '#8B008B'
            }, // 4
            {
                radius: 64,
                fileName: '崔梓璇06.gif',
                score: 64,
                backgroundColor: '#8B008B',
                borderColor: '#4B0082'
            }, // 5
            {
                radius: 76,
                fileName: '崔梓璇07.gif',
                score: 128,
                backgroundColor: '#9400D3',
                borderColor: '#8A2BE2'
            }, // 6
            {
                radius: 88,
                fileName: '崔梓璇08.gif',
                score: 256,
                backgroundColor: '#9932CC',
                borderColor: '#BA55D3'
            }, // 7
            {
                radius: 100,
                fileName: '崔梓璇09.gif',
                score: 512,
                backgroundColor: '#BA55D3',
                borderColor: '#DA70D6'
            }, // 8
            {
                radius: 115,
                fileName: '崔梓璇10.gif',
                score: 1024,
                backgroundColor: '#DA70D6',
                borderColor: '#D8BFD8'
            }, // 9
            {
                radius: 135,
                fileName: '崔梓璇11.png',
                score: 2048,
                backgroundColor: '#228B22',
                borderColor: '#3CB371'
            } // 10: 终极
        ];

        // 预加载系统
        const textureCache = []; // 存储 { url, scaleX, scaleY, loaded }

        function preloadImages() {
            FRUIT_LEVELS.forEach((level, index) => {
                const img = new Image();
                const url = IMG_PATH + level.fileName;

                textureCache[index] = {
                    url: url,
                    scale: 1,
                    loaded: false
                };

                img.onload = function() {
                    const diameter = level.radius * 2;
                    const scale = diameter / img.width; // 假设图片宽度与高度大致相同

                    textureCache[index].scale = scale;
                    textureCache[index].loaded = true;

                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.onerror = function() {
                    console.error("加载图片失败:", url);
                    textureCache[index].loaded = false; // 标记为加载失败
                    if (index === nextFruitLevel) { // 如果是当前下一个球，更新UI显示
                        updateUI();
                    }
                };

                img.src = url;
            });
        }

        preloadImages();


        // ===========================
        // Matter.js 初始化
        // ===========================
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            World = Matter.World,
            Events = Matter.Events,
            Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;

        const canvas = document.getElementById('world');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        let canvasWidth = canvasWrapper.clientWidth;
        let canvasHeight = canvasWrapper.clientHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvasWidth,
                height: canvasHeight,
                wireframes: false,
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });

        // ===========================
        // 游戏状态变量
        // ===========================
        let currentFruit = null;
        let nextFruitLevel = 0;
        let score = 0;
        let isDropping = false;
        let isGameOver = false;
        const SPAWN_Y = 50;

        // ===========================
        // 游戏辅助函数
        // ===========================

        function createWalls() {
            const wallThickness = 60;
            const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth + wallThickness * 2, wallThickness, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const leftWall = Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const rightWall = Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            World.add(world, [ground, leftWall, rightWall]);
        }

        function createFruitBody(x, y, levelIndex, isSensor = false) {
            const levelData = FRUIT_LEVELS[levelIndex];
            const textureData = textureCache[levelIndex];

            const options = {
                isSensor: isSensor,
                isStatic: isSensor,
                restitution: 0.2,
                friction: 0.1,
                density: 0.002,
                label: 'fruit_' + levelIndex,
                render: {
                    // 如果图片加载成功，使用图片作为 sprite 纹理
                    sprite: {
                        texture: textureData && textureData.loaded ? textureData.url : undefined, // undefined 不会渲染 sprite
                        xScale: textureData && textureData.loaded ? textureData.scale : 1,
                        yScale: textureData && textureData.loaded ? textureData.scale : 1
                    },
                    // 始终设置 fillStyle 和 strokeStyle 来绘制圆形背景和边框
                    fillStyle: levelData.backgroundColor,
                    strokeStyle: levelData.borderColor,
                    lineWidth: 3 // 描边宽度
                }
            };

            return Bodies.circle(x, y, levelData.radius, options);
        }

        function getRandomNextLevel() {
            return Math.floor(Math.random() * 5);
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            const previewContainer = document.getElementById('next-item-preview');
            previewContainer.innerHTML = '';

            const textureData = textureCache[nextFruitLevel];
            const levelData = FRUIT_LEVELS[nextFruitLevel];

            // 设置预览框的背景和描边
            previewContainer.style.backgroundColor = levelData.backgroundColor;
            previewContainer.style.borderColor = levelData.borderColor;

            if (textureData && textureData.loaded) {
                const img = new Image();
                img.src = textureData.url;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.borderRadius = '50%'; // 尝试在UI预览中裁剪为圆形
                previewContainer.appendChild(img);
                previewContainer.style.color = 'transparent'; // 如果有图片，文字不可见
            } else {
                // 如果图片未加载，显示等级数字
                previewContainer.innerText = (nextFruitLevel + 1).toString();
                previewContainer.style.color = 'white';
                previewContainer.style.fontWeight = 'bold';
                previewContainer.style.fontSize = '20px';
                previewContainer.style.display = 'flex';
                previewContainer.style.alignItems = 'center';
                previewContainer.style.justifyContent = 'center';
            }
        }

        function spawnCurrentFruit() {
            if (isGameOver) return;
            const level = nextFruitLevel;
            currentFruit = createFruitBody(canvasWidth / 2, SPAWN_Y, level, true);
            World.add(world, currentFruit);

            nextFruitLevel = getRandomNextLevel();
            updateUI();
            isDropping = false;
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('game-over-overlay').style.display = 'flex';
            if (currentFruit) World.remove(world, currentFruit);
        }

        Events.on(engine, 'afterUpdate', function() {
            if (isGameOver || isDropping) return;

            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label.startsWith('fruit_') && !body.isSensor) {
                    if (body.position.y < 80 && body.speed < 0.2) {
                        gameOver();
                        break;
                    }
                }
            }
        });


        // ===========================
        // 核心逻辑：碰撞与合并
        // ===========================
        Events.on(engine, 'collisionStart', function(event) {
            if (isGameOver) return;
            const pairs = event.pairs;

            const removedBodies = new Set();

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

                if (bodyA.label.startsWith('fruit_') && bodyB.label.startsWith('fruit_')) {
                    const levelA = parseInt(bodyA.label.split('_')[1]);
                    const levelB = parseInt(bodyB.label.split('_')[1]);

                    if (levelA === levelB && levelA < FRUIT_LEVELS.length - 1) {
                        removedBodies.add(bodyA.id);
                        removedBodies.add(bodyB.id);

                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        World.remove(world, [bodyA, bodyB]);

                        const newLevel = levelA + 1;
                        const newFruit = createFruitBody(midX, midY, newLevel);
                        World.add(world, newFruit);

                        score += FRUIT_LEVELS[newLevel].score;
                        document.getElementById('score').innerText = score;
                    }
                }
            }
        });


        // ===========================
        // 输入事件处理 (触摸与鼠标)
        // ===========================
        function handleInputMove(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();

            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = canvas.getBoundingClientRect();
            let relativeX = clientX - rect.left;

            const currentLevel = parseInt(currentFruit.label.split('_')[1]);
            const radius = FRUIT_LEVELS[currentLevel].radius;
            relativeX = Math.max(radius, Math.min(canvasWidth - radius, relativeX));

            Matter.Body.setPosition(currentFruit, {
                x: relativeX,
                y: SPAWN_Y
            });
        }

        function handleInputEnd(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();
            isDropping = true;

            Matter.Body.setStatic(currentFruit, false);
            currentFruit.isSensor = false;
            currentFruit = null;

            setTimeout(spawnCurrentFruit, 600);
        }

        canvasWrapper.addEventListener('mousemove', handleInputMove);
        canvasWrapper.addEventListener('touchmove', handleInputMove, {
            passive: false
        });
        canvasWrapper.addEventListener('mouseup', handleInputEnd);
        canvasWrapper.addEventListener('touchend', handleInputEnd, {
            passive: false
        });
        canvasWrapper.addEventListener('click', handleInputEnd);

        document.getElementById('restart-btn').addEventListener('click', function() {
            World.clear(world);
            Engine.clear(engine);
            score = 0;
            isGameOver = false;
            document.getElementById('game-over-overlay').style.display = 'none';
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            spawnCurrentFruit();
            Runner.run(runner, engine);
        });


        // ===========================
        // 启动游戏
        // ===========================
        setTimeout(() => {
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            updateUI();
            spawnCurrentFruit();

            Render.run(render);
            const runner = Runner.create();
            Runner.run(runner, engine);
        }, 100);

        window.addEventListener('resize', function() {
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            World.clear(world, true);
            createWalls();
        });
    </script>
</body>

</html>