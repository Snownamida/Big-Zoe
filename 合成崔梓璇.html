<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>合成崔梓璇</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        /* CSS reset 和基础样式 */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* 禁止移动端长按选中文字和图片 */
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            /* 禁止滚动 */
            background-color: #ffe4e1;
            /* 少女粉底色 */
            font-family: 'Arial', sans-serif;
            /* 柔和的背景渐变 */
            background-image: radial-gradient(circle at 50% 30%, #fff0f5 0%, #ffe4e1 80%);
        }
        /* 游戏主容器 */
        
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            max-width: 500px;
            /*在大屏幕上限制最大宽度 */
            margin: 0 auto;
            background: transparent;
        }
        /* 顶部导航栏 */
        
        .header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            font-size: 18px;
            font-weight: bold;
            color: #d63384;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.8);
        }
        
        .header-icons span {
            margin-left: 10px;
            cursor: pointer;
        }
        /* 游戏UI栏 (分数和下一个提示) */
        
        .game-ui-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 20px;
            color: #d63384;
            z-index: 10;
        }
        
        .score-box {
            font-size: 24px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.6);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .next-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .next-label {
            font-size: 14px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        /* 下一个提示的容器 */
        
        #next-item-preview {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 3px solid #fff;
            overflow: hidden;
            /* 确保图片不溢出 */
            box-shadow: 0 2px 10px rgba(214, 51, 132, 0.2);
        }
        
        #next-item-preview img {
            display: block;
            object-fit: contain;
        }
        /* Canvas 画布容器 */
        
        #canvas-wrapper {
            flex: 1;
            position: relative;
            width: 100%;
            margin-bottom: 10px;
            overflow: hidden;
            /* 容器边框 */
            border-left: 2px solid rgba(255, 255, 255, 0.5);
            border-right: 2px solid rgba(255, 255, 255, 0.5);
            border-bottom: 2px solid rgba(255, 255, 255, 0.5);
        }
        /* 实际的游戏画布 */
        
        #world {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* 游戏结束遮罩 */
        
        #game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.85);
            color: #d63384;
            display: none;
            /* 默认隐藏 */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
        }
        
        #game-over-overlay h2 {
            font-size: 32px;
            margin-bottom: 20px;
        }
        
        #restart-btn {
            padding: 12px 30px;
            font-size: 20px;
            background: #d63384;
            border: none;
            color: white;
            border-radius: 25px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(214, 51, 132, 0.4);
            transition: transform 0.1s;
        }
        
        #restart-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>

<body>

    <div id="game-container">
        <div class="header-bar">
            <div>合成崔梓璇</div>
            <div class="header-icons"><span>•••</span></div>
        </div>

        <div class="game-ui-bar">
            <div class="score-box"><span id="score">0</span></div>
            <div class="next-box">
                <span class="next-label">下一个:</span>
                <div id="next-item-preview">
                    <!-- 下一个提示图片将在这里显示 -->
                </div>
            </div>
        </div>

        <div id="canvas-wrapper">
            <canvas id="world"></canvas>
            <div id="game-over-overlay">
                <h2>游戏结束</h2>
                <button id="restart-btn">再来一次</button>
            </div>
        </div>
    </div>


    <script>
        // ===========================
        // 游戏配置与素材定义
        // ===========================

        // 基础路径 - 确保 HTML 文件和 images 文件夹在同一级目录
        const IMG_PATH = 'images/';

        // 定义 11 个等级的属性
        // radius: 物理碰撞半径 (px)
        // fileName: 对应的文件名
        // score: 合成得分
        const FRUIT_LEVELS = [{
                radius: 18,
                fileName: '崔梓璇01.gif',
                score: 2
            }, // 0
            {
                radius: 26,
                fileName: '崔梓璇02.gif',
                score: 4
            }, // 1
            {
                radius: 34,
                fileName: '崔梓璇03.gif',
                score: 8
            }, // 2
            {
                radius: 42,
                fileName: '崔梓璇04.gif',
                score: 16
            }, // 3
            {
                radius: 52,
                fileName: '崔梓璇05.gif',
                score: 32
            }, // 4
            {
                radius: 64,
                fileName: '崔梓璇06.gif',
                score: 64
            }, // 5
            {
                radius: 76,
                fileName: '崔梓璇07.gif',
                score: 128
            }, // 6
            {
                radius: 88,
                fileName: '崔梓璇08.gif',
                score: 256
            }, // 7
            {
                radius: 100,
                fileName: '崔梓璇09.gif',
                score: 512
            }, // 8
            {
                radius: 115,
                fileName: '崔梓璇10.gif',
                score: 1024
            }, // 9
            {
                radius: 135,
                fileName: '崔梓璇11.png',
                score: 2048
            } // 10: 终极
        ];

        // 预加载系统
        // 我们需要加载图片以获取其原始尺寸，从而计算缩放比例(scale)，
        // 这样无论原图多大，都能完美缩放到 radius 大小。
        const textureCache = []; // 存储 { url, scaleX, scaleY, loaded }
        const fallbackColors = ['#FFB6C1', '#FF69B4', '#FF1493', '#DB7093', '#C71585', '#8B008B', '#9400D3', '#9932CC', '#BA55D3', '#DA70D6', '#228B22'];

        function preloadImages() {
            FRUIT_LEVELS.forEach((level, index) => {
                const img = new Image();
                const url = IMG_PATH + level.fileName;

                // 初始化缓存对象
                textureCache[index] = {
                    url: url,
                    scale: 1, // 默认缩放
                    loaded: false
                };

                img.onload = function() {
                    // 计算缩放比例：目标直径 / 图片原始宽度
                    // 我们假设图片是正方形或者接近正方形，基于宽度进行缩放
                    const diameter = level.radius * 2;
                    const scale = diameter / img.width;

                    textureCache[index].scale = scale;
                    textureCache[index].loaded = true;

                    // 如果第一张图加载完了，刷新一下UI预览
                    if (index === nextFruitLevel) {
                        updateUI();
                    }
                };

                img.onerror = function() {
                    console.error("加载图片失败:", url);
                    // 加载失败保持 loaded = false，生成物体时会使用颜色回退
                };

                img.src = url;
            });
        }

        // 立即开始预加载
        preloadImages();


        // ===========================
        // Matter.js 初始化
        // ===========================
        const Engine = Matter.Engine,
            Render = Matter.Render,
            Runner = Matter.Runner,
            Bodies = Matter.Bodies,
            World = Matter.World,
            Events = Matter.Events,
            Composite = Matter.Composite;

        const engine = Engine.create();
        const world = engine.world;

        const canvas = document.getElementById('world');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        let canvasWidth = canvasWrapper.clientWidth;
        let canvasHeight = canvasWrapper.clientHeight;

        const render = Render.create({
            canvas: canvas,
            engine: engine,
            options: {
                width: canvasWidth,
                height: canvasHeight,
                wireframes: false, // 必须关闭线框模式才能显示贴图
                background: 'transparent',
                pixelRatio: window.devicePixelRatio
            }
        });

        // ===========================
        // 游戏状态变量
        // ===========================
        let currentFruit = null;
        let nextFruitLevel = 0;
        let score = 0;
        let isDropping = false;
        let isGameOver = false;
        const SPAWN_Y = 50;

        // ===========================
        // 游戏辅助函数
        // ===========================

        // 创建边界墙壁
        function createWalls() {
            const wallThickness = 60;
            const ground = Bodies.rectangle(canvasWidth / 2, canvasHeight + wallThickness / 2, canvasWidth + wallThickness * 2, wallThickness, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const leftWall = Bodies.rectangle(-wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            const rightWall = Bodies.rectangle(canvasWidth + wallThickness / 2, canvasHeight / 2, wallThickness, canvasHeight * 2, {
                isStatic: true,
                render: {
                    visible: false
                }
            });
            World.add(world, [ground, leftWall, rightWall]);
        }

        // 创建一个水果刚体
        function createFruitBody(x, y, levelIndex, isSensor = false) {
            const levelData = FRUIT_LEVELS[levelIndex];
            const textureData = textureCache[levelIndex];

            const options = {
                isSensor: isSensor,
                isStatic: isSensor,
                restitution: 0.2,
                friction: 0.1,
                density: 0.002, // 稍微增加密度让手感更扎实
                label: 'fruit_' + levelIndex,
                render: {
                    sprite: {
                        // 如果图片加载成功，使用图片，否则不设置纹理（Matter.js会显示默认颜色）
                        texture: textureData && textureData.loaded ? textureData.url : null,
                        xScale: textureData && textureData.loaded ? textureData.scale : 1,
                        yScale: textureData && textureData.loaded ? textureData.scale : 1
                    },
                    // 如果图片没加载出来，设置一个备用颜色
                    fillStyle: fallbackColors[levelIndex] || '#ccc'
                }
            };

            return Bodies.circle(x, y, levelData.radius, options);
        }

        // 生成下一个随机水果等级 (只生成前5种小水果)
        function getRandomNextLevel() {
            return Math.floor(Math.random() * 5);
        }

        // 更新 UI 显示
        function updateUI() {
            document.getElementById('score').innerText = score;
            const previewContainer = document.getElementById('next-item-preview');
            previewContainer.innerHTML = '';

            const textureData = textureCache[nextFruitLevel];

            if (textureData && textureData.loaded) {
                // 如果图片已加载，显示图片
                const img = new Image();
                img.src = textureData.url;
                // 限制预览图大小
                img.style.width = '100%';
                img.style.height = '100%';
                previewContainer.appendChild(img);
                previewContainer.style.backgroundColor = 'transparent';
            } else {
                // 如果图片未加载，显示颜色块
                previewContainer.style.backgroundColor = fallbackColors[nextFruitLevel];
                previewContainer.innerText = nextFruitLevel + 1; // 显示数字代号
                previewContainer.style.color = 'white';
                previewContainer.style.fontWeight = 'bold';
            }
        }

        // 生成顶部当前等待的水果
        function spawnCurrentFruit() {
            if (isGameOver) return;
            const level = nextFruitLevel;
            currentFruit = createFruitBody(canvasWidth / 2, SPAWN_Y, level, true);
            World.add(world, currentFruit);

            nextFruitLevel = getRandomNextLevel();
            updateUI();
            isDropping = false;
        }

        // 游戏结束逻辑
        function gameOver() {
            isGameOver = true;
            document.getElementById('game-over-overlay').style.display = 'flex';
            // 移除当前的悬停球
            if (currentFruit) World.remove(world, currentFruit);
        }

        // 检查游戏结束
        Events.on(engine, 'afterUpdate', function() {
            if (isGameOver || isDropping) return;

            // 逻辑：如果有“非Sensor(已落地)”的水果，且静止，且位置高于警戒线
            const bodies = Composite.allBodies(world);
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (body.label.startsWith('fruit_') && !body.isSensor) {
                    // 判定高度：如果球心 y 坐标 < 100 (接近顶部) 且速度极慢
                    if (body.position.y < 80 && body.speed < 0.2) {
                        // 再给一点缓冲时间确认不是反弹上去的
                        // 这里简单处理直接判负，实际项目可加计时器
                        gameOver();
                        break;
                    }
                }
            }
        });


        // ===========================
        // 核心逻辑：碰撞与合并
        // ===========================
        Events.on(engine, 'collisionStart', function(event) {
            if (isGameOver) return;
            const pairs = event.pairs;

            // 使用 Set 防止同一帧内同一个物体被多次处理
            const removedBodies = new Set();

            for (let i = 0; i < pairs.length; i++) {
                const bodyA = pairs[i].bodyA;
                const bodyB = pairs[i].bodyB;

                if (removedBodies.has(bodyA.id) || removedBodies.has(bodyB.id)) continue;

                if (bodyA.label.startsWith('fruit_') && bodyB.label.startsWith('fruit_')) {
                    const levelA = parseInt(bodyA.label.split('_')[1]);
                    const levelB = parseInt(bodyB.label.split('_')[1]);

                    if (levelA === levelB && levelA < FRUIT_LEVELS.length - 1) {
                        // 记录要移除的物体
                        removedBodies.add(bodyA.id);
                        removedBodies.add(bodyB.id);

                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;

                        // 移除旧的
                        World.remove(world, [bodyA, bodyB]);

                        // 创建新的
                        const newLevel = levelA + 1;
                        const newFruit = createFruitBody(midX, midY, newLevel);
                        World.add(world, newFruit);

                        // 加分
                        score += FRUIT_LEVELS[newLevel].score;
                        document.getElementById('score').innerText = score;
                    }
                }
            }
        });


        // ===========================
        // 输入事件处理 (触摸与鼠标)
        // ===========================
        function handleInputMove(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();

            let clientX;
            if (e.type.startsWith('touch')) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = canvas.getBoundingClientRect();
            let relativeX = clientX - rect.left;

            // 限制移动范围
            const currentLevel = parseInt(currentFruit.label.split('_')[1]);
            const radius = FRUIT_LEVELS[currentLevel].radius;
            relativeX = Math.max(radius, Math.min(canvasWidth - radius, relativeX));

            Matter.Body.setPosition(currentFruit, {
                x: relativeX,
                y: SPAWN_Y
            });
        }

        function handleInputEnd(e) {
            if (isGameOver || isDropping || !currentFruit) return;
            e.preventDefault();
            isDropping = true;

            Matter.Body.setStatic(currentFruit, false);
            currentFruit.isSensor = false;
            currentFruit = null;

            setTimeout(spawnCurrentFruit, 600);
        }

        canvasWrapper.addEventListener('mousemove', handleInputMove);
        canvasWrapper.addEventListener('touchmove', handleInputMove, {
            passive: false
        });
        canvasWrapper.addEventListener('mouseup', handleInputEnd);
        canvasWrapper.addEventListener('touchend', handleInputEnd, {
            passive: false
        });
        canvasWrapper.addEventListener('click', handleInputEnd);

        // 重新开始按钮
        document.getElementById('restart-btn').addEventListener('click', function() {
            World.clear(world);
            Engine.clear(engine);
            score = 0;
            isGameOver = false;
            document.getElementById('game-over-overlay').style.display = 'none';
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            spawnCurrentFruit();
            Runner.run(runner, engine);
        });


        // ===========================
        // 启动游戏
        // ===========================
        // 稍微延时启动，给图片预加载一点点时间（虽然我们有热加载机制）
        setTimeout(() => {
            createWalls();
            nextFruitLevel = getRandomNextLevel();
            updateUI();
            spawnCurrentFruit();

            Render.run(render);
            const runner = Runner.create();
            Runner.run(runner, engine);
        }, 100);

        // 窗口大小适配
        window.addEventListener('resize', function() {
            canvasWidth = canvasWrapper.clientWidth;
            canvasHeight = canvasWrapper.clientHeight;
            render.canvas.width = canvasWidth;
            render.canvas.height = canvasHeight;
            World.clear(world, true);
            createWalls();
        });
    </script>
</body>

</html>